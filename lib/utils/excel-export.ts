/**
 * Excel Export Utilities
 * Handles conversion of data to Excel format using xlsx library
 */

import * as XLSX from 'xlsx';

export interface ExcelExportOptions {
  filename?: string;
  sheetName?: string;
  includeHeaders?: boolean;
  dateFormat?: string;
}

export class ExcelExporter {
  /**
   * Convert an array of objects to Excel format
   */
  static arrayToExcel<T extends Record<string, any>>(
    data: T[],
    options: ExcelExportOptions = {}
  ): Buffer {
    const {
      sheetName = 'Sheet1',
      includeHeaders = true,
      dateFormat = 'yyyy-mm-dd'
    } = options;

    if (data.length === 0) {
      // Create empty workbook with headers
      const emptyData = [{}];
      const ws = XLSX.utils.json_to_sheet(emptyData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, sheetName);
      return XLSX.write(wb, { type: 'buffer', bookType: 'xlsx' });
    }

    // Convert data to worksheet
    const ws = XLSX.utils.json_to_sheet(data, {
      header: includeHeaders ? Object.keys(data[0]) : undefined,
      dateNF: dateFormat
    });

    // Create workbook
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, sheetName);

    // Generate Excel buffer
    return XLSX.write(wb, { type: 'buffer', bookType: 'xlsx' });
  }

  /**
   * Convert analytics data to Excel format with multiple sheets
   */
  static analyticsToExcel(analyticsData: any): Buffer {
    const wb = XLSX.utils.book_new();

    // Add metadata sheet
    const metadata = [
      ['Analytics Export'],
      ['Exported At', analyticsData.exportedAt],
      ['Company ID', analyticsData.companyId],
      [''],
      ['Generated by Benefits AI Chatbot'],
      ['Export Date', new Date().toISOString()]
    ];
    const metadataWs = XLSX.utils.aoa_to_sheet(metadata);
    XLSX.utils.book_append_sheet(wb, metadataWs, 'Metadata');

    // Add chat analytics sheet
    if (analyticsData.analytics?.chat) {
      const chatData = this.prepareChatAnalyticsForExcel(analyticsData.analytics.chat);
      const chatWs = XLSX.utils.json_to_sheet(chatData);
      XLSX.utils.book_append_sheet(wb, chatWs, 'Chat Analytics');
    }

    // Add company analytics sheet
    if (analyticsData.analytics?.company) {
      const companyData = this.prepareCompanyAnalyticsForExcel(analyticsData.analytics.company);
      const companyWs = XLSX.utils.json_to_sheet(companyData);
      XLSX.utils.book_append_sheet(wb, companyWs, 'Company Analytics');
    }

    // Add user activity sheet
    if (analyticsData.analytics?.users && analyticsData.analytics.users.length > 0) {
      const userData = this.prepareUserActivityForExcel(analyticsData.analytics.users);
      const userWs = XLSX.utils.json_to_sheet(userData);
      XLSX.utils.book_append_sheet(wb, userWs, 'User Activity');
    }

    // Add system metrics sheet
    if (analyticsData.analytics?.systemMetrics) {
      const systemData = this.prepareSystemMetricsForExcel(analyticsData.analytics.systemMetrics);
      const systemWs = XLSX.utils.json_to_sheet(systemData);
      XLSX.utils.book_append_sheet(wb, systemWs, 'System Metrics');
    }

    return XLSX.write(wb, { type: 'buffer', bookType: 'xlsx' });
  }

  /**
   * Convert chat messages to Excel format
   */
  static chatMessagesToExcel(messages: any[]): Buffer {
    const data = messages.map((message, index) => ({
      'Message #': index + 1,
      'Timestamp': message.timestamp || message.createdAt,
      'User ID': message.userId,
      'Message Type': message.type || 'user',
      'Content': message.content,
      'Tokens Used': message.tokensUsed || 0,
      'Response Time (ms)': message.responseTime || 0
    }));

    return this.arrayToExcel(data, {
      sheetName: 'Chat Messages',
      filename: 'chat-messages.xlsx'
    });
  }

  /**
   * Convert user activity to Excel format
   */
  static userActivityToExcel(users: any[]): Buffer {
    const data = users.map(user => ({
      'User ID': user.id,
      'Email': user.email,
      'Display Name': user.displayName,
      'Role': user.role,
      'Last Active': user.lastActive,
      'Total Chats': user.totalChats || 0,
      'Total Messages': user.totalMessages || 0,
      'Status': user.status || 'active',
      'Created At': user.createdAt,
      'Company ID': user.companyId
    }));

    return this.arrayToExcel(data, {
      sheetName: 'User Activity',
      filename: 'user-activity.xlsx'
    });
  }

  /**
   * Create a downloadable Excel file
   */
  static createDownloadableExcel(
    excelBuffer: Buffer,
    filename: string = 'export.xlsx'
  ): { content: Buffer; headers: Record<string, string> } {
    return {
      content: excelBuffer,
      headers: {
        'Content-Type': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'Content-Disposition': `attachment; filename="${filename}"`,
        'Cache-Control': 'no-cache, no-store, must-revalidate',
        'Pragma': 'no-cache',
        'Expires': '0',
        'Content-Length': excelBuffer.length.toString()
      }
    };
  }

  // Helper methods for preparing data for Excel
  private static prepareChatAnalyticsForExcel(chatData: any): any[] {
    const data = [
      { 'Metric': 'Total Chats', 'Value': chatData.totalChats || 0 },
      { 'Metric': 'Average Messages per Chat', 'Value': chatData.averageMessagesPerChat || 0 },
      { 'Metric': 'Total Questions', 'Value': chatData.totalQuestions || 0 },
      { 'Metric': 'Average Response Time (ms)', 'Value': chatData.averageResponseTime || 0 },
      { 'Metric': 'Satisfaction Rate (%)', 'Value': (chatData.satisfactionRate || 0) * 100 },
      { 'Metric': 'Total Tokens Used', 'Value': chatData.totalTokensUsed || 0 },
      { 'Metric': 'Cost per Chat', 'Value': chatData.costPerChat || 0 }
    ];

    // Add top questions
    if (chatData.topQuestions && chatData.topQuestions.length > 0) {
      data.push({ 'Metric': '', 'Value': '' }); // Empty row
      data.push({ 'Metric': 'Top Questions', 'Value': '' });
      chatData.topQuestions.forEach((q: any, index: number) => {
        data.push({
          'Metric': `Question ${index + 1}`,
          'Value': q.question || q
        });
      });
    }

    return data;
  }

  private static prepareCompanyAnalyticsForExcel(companyData: any): any[] {
    return [
      { 'Metric': 'Total Users', 'Value': companyData.totalUsers || 0 },
      { 'Metric': 'Active Users', 'Value': companyData.activeUsers || 0 },
      { 'Metric': 'Total Documents', 'Value': companyData.totalDocuments || 0 },
      { 'Metric': 'Storage Used (MB)', 'Value': companyData.storageUsed || 0 },
      { 'Metric': 'Average Response Time (ms)', 'Value': companyData.averageResponseTime || 0 },
      { 'Metric': 'Satisfaction Rate (%)', 'Value': (companyData.satisfactionRate || 0) * 100 }
    ];
  }

  private static prepareUserActivityForExcel(users: any[]): any[] {
    return users.map(user => ({
      'User ID': user.id,
      'Email': user.email,
      'Display Name': user.displayName,
      'Role': user.role,
      'Last Active': user.lastActive,
      'Total Chats': user.totalChats || 0,
      'Total Messages': user.totalMessages || 0,
      'Status': user.status || 'active',
      'Created At': user.createdAt,
      'Company ID': user.companyId
    }));
  }

  private static prepareSystemMetricsForExcel(systemMetrics: any): any[] {
    return [
      { 'Metric': 'CPU Usage (%)', 'Value': systemMetrics.cpuUsage || 0 },
      { 'Metric': 'Memory Usage (%)', 'Value': systemMetrics.memoryUsage || 0 },
      { 'Metric': 'Disk Usage (%)', 'Value': systemMetrics.diskUsage || 0 },
      { 'Metric': 'Network Latency (ms)', 'Value': systemMetrics.networkLatency || 0 },
      { 'Metric': 'Error Rate (%)', 'Value': systemMetrics.errorRate || 0 },
      { 'Metric': 'Uptime (seconds)', 'Value': systemMetrics.uptime || 0 }
    ];
  }
}
